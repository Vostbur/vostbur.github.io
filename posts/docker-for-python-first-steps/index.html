<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker для python. Первые шаги | Little things about IT</title>
<meta name=keywords content="python,docker"><meta name=description content="Docker для python. Первые шаги."><meta name=author content><link rel=canonical href=https://vostbur.github.io/posts/docker-for-python-first-steps/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://vostbur.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://vostbur.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://vostbur.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://vostbur.github.io/apple-touch-icon.png><link rel=mask-icon href=https://vostbur.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.146.6"><link rel=alternate hreflang=en href=https://vostbur.github.io/posts/docker-for-python-first-steps/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Docker для python. Первые шаги"><meta property="og:description" content="Docker для python. Первые шаги."><meta property="og:type" content="article"><meta property="og:url" content="https://vostbur.github.io/posts/docker-for-python-first-steps/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-04T00:00:00+00:00"><meta property="article:modified_time" content="2022-01-04T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker для python. Первые шаги"><meta name=twitter:description content="Docker для python. Первые шаги."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vostbur.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Docker для python. Первые шаги","item":"https://vostbur.github.io/posts/docker-for-python-first-steps/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker для python. Первые шаги","name":"Docker для python. Первые шаги","description":"Docker для python. Первые шаги.","keywords":["python","docker"],"articleBody":"Если не вдаваться в технические детали Docker ближе всего к VirtualBox, VMware или другим средствам виртуализации. Технические отличия заключаются в других способах изоляции запускаемой гостевой (guest) операционной системы и разделения ресурсов основной (host) операционной системы. Как правило каждый работающий в Docker экземпляр гостевой операционной системы предназначен для запуска одного единственного приложения. При этом задействуется меньше ресурсов, чем при запуске в виртуальной машине. Для этого создается своя файловая система, свои виртуальные сетевые интерфейсы - как бы контейнер внутри которого приложение работает. Docker это программное обеспечение для контейнеризации приложений.\nОсновные понятия, которые надо различать, это образ (image) и контейнер (container). Если совсем просто - образ это готовый для запуска в Docker пакет, контейнер это запущенный в Docker образ. Образ Docker можно представить как iso-образ дистрибутива операционной системы, а контейнер - запущенный экземпляр операционной системы в виртуальной машине. Из одного образа можно запустить несколько контейнеров.\nОбраз создается из конфигурационного текстового файла. Новый образ можно создать на основе уже существующего. Как правило конфигурационный файл начинается с команды, которая указывает на существующий образ, взятый за основу и дополняется командами для установки дополнительного программного обеспечения или изменения конфигурации.\nДля опубликования своих образов существуют репозитории, самый популярный из которых Docker Hub.\nНачнем с самого простого примера. Выполним команду\n$ docker run hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 2db29710123e: Pull complete Digest: sha256:cc15c5b292d8525effc0f89cb299f1804f3a725c8d05e158653a563f15e4f685 Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ Команда run запускает контейнер. Разберем каждую строку\nUnable to find image 'hello-world:latest' locally Сначала Docker ищет запрашиваемый образ на локальной машине, если не находит - продолжает поиск в репозитории. По умолчанию это Docker Hub. Название образа состоит из двух частей: название и версия. Docker сам добавляет номер версии latest к названию, если пользователь не указал что-то другое.\nlatest: Pulling from library/hello-world Docker нашел подходящий образ в репозитории и готов его скачать.\n2db29710123e: Pull complete Digest: sha256:cc15c5b292d8525effc0f89cb299f1804f3a725c8d05e158653a563f15e4f685 Status: Downloaded newer image for hello-world:latest Образ скачан, в выводе указан результат вычисления хэш-функции, подсчитанный по алгоритму sha256 для проверки образа. Всё остальное это результат выполнения приложения в запущенном контейнере. Результат работы этого примера сам по себе интересен - в выводе информация об этапах запуска контейнера. Там же еще одна интересная команда\n$ docker run -it ubuntu bash По этой команде запускается контейнер из образа ubuntu:latest и управление передается выполняемой в контейнере командной оболочке bash.\nОпции -i или --interactive и -t или --tty (или вместе -it) позволяют запустить в контейнере интерактивные (взаимодействующие с пользователем) приложение. Они указывают Docker оставить стандартный вход (stdin) в открытом состоянии и выделить псевдо-терминал, который соединяет используемый терминал с потоками stdin и stdout контейнера. Если это сложно, то достаточно запомнить, что опции -it позволяют перейти в контейнер и запустить команду, ожидающую ввода пользователя.\nНапример команда\n$ docker run -it --rm python Запустит REPL python последней версии. Опция --rm автоматически удаляет контейнер после того, как его выполнение завершится.\nТеперь создадим свой первый образ для запуска контейнера, который будет выполнять скрипт на python. Скрипт самый простой\nprint(\"Hello, world!\") сохраним его в файл hello.py. Конфигурационный файл docker-образа называется Dockerfile. Создадим Dockerfile такого содержания:\nFROM python COPY hello.py / ENTRYPOINT [ \"python\", \"./example.py\" ] Каждая строчка файла начинается с команды. Команды принято записывать заглавными буквами, но это не обязательно. Команды выполняются последовательно, в том порядке, в каком они указаны в Dockerfile.\nFROM python - указываем, что будем делать свой образ на основе базового образа python последней версии (latest) из репозитория Docker Hub.\nCOPY hello.py / - скопируем наш скрипт hello.py из текущего каталога (тот же каталог, где находится и Dockerfile) в корневой каталог файловой системы образа.\nENTRYPOINT [ \"python\", \"/hello.py\" ] - запустим наш скрипт командой python /hello.py\nТеперь соберем наш образ командой build\n$ docker build -t hello-py:1.0 . Точка в конце команды указывает, что Dockerfile для сборки образа находится в текущем каталоге.\nОпция -t (tag) команды build позволяет задать имя и версию нашему образу. Если версию не указывать, Docker автоматически добавить latest. Если не указывать имя, к образу можно будет обратиться по значению IMAGE ID. Узнать, какие образы у нас уже есть можно командой\n$ docker images или\n$ docker image ls Это идентичные команды, но лучше пользоваться вторым вариантом. Он введен для приведения команд Docker к некоторому унифицированному виду. Все команды, которые управляют образами находятся в разделе docker image, контейнерами - docker container.\nREPOSITORY TAG IMAGE ID CREATED SIZE 6af91789bf03 20 minutes ago 917MB python latest a42e2a4f3833 5 days ago 917MB Здесь видно, что при создании образа не было указано имя. Контейнер в таком случае можно запустить командой\n$ docker run 6af91789bf03 Если указано имя, команда для запуска контейнера может быть более удобочитаемой\n$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE hello-py 1.0 6af91789bf03 22 minutes ago 917MB python latest a42e2a4f3833 5 days ago 917MB $ docker run hello-py:1.0 Контейнер мы запустили без опции --rm, значит после завершения выполнения, он не удалился. Посмотреть существующие контейнеры можно командой\n$ docker ps -a или\n$ docker container ls -a Команды идентичны, как в случает с docker images и docker image ls. Опция -a указывает выводить все контейнеры, запущенные и уже остановленные\n$ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9839a6c57209 hello-py:1.0 \"python /hello.py\" 5 seconds ago Exited (0) 4 seconds ago upbeat_noyce Каждому контейнеру присваивается случайное имя. В этом случае это upbeat_noyce. Но при создании контейнера можно указать и свое значение имени используя опцию --name.\n$ docker run --name hello-world hello-py:1.0 в этом случае список контейнеров будет такой\n$ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 11794828bf57 hello-py:1.0 \"python /hello.py\" 29 seconds ago Exited (0) 29 seconds ago hello-world 9839a6c57209 hello-py:1.0 \"python /hello.py\" 3 minutes ago Exited (0) 3 minutes ago upbeat_noyce Удалить остановленные контейнеры можно командой docker container rm \u003cимя_контейнера\u003e\n$ docker container rm hello-world Удалить локальные образы можно командой docker image rm \u003cимя образа\u003e\n$ docker image rm hello-py:1.0 Усложним наш скрипт. Запустим в контейнере web-приложение выводящее на главную страницу Hello, world! В качестве сервера будем использовать Flask.\nНаш новый файл hello.py\nfrom flask import Flask app = Flask(__name__) @app.route(\"/\") def index(): return \"Hello, world!\" if __name__ == \"__main__\": app.run(host=\"0.0.0.0\", port=5000) Изменим Dockerfile, добавим только одну команду, с помощью которой установим flask.\nFROM python RUN python -m pip install Flask COPY hello.py / ENTRYPOINT [\"python\", \"/hello.py\"] Немного о порядке команд в Dockerfile. Docker выполняет команды по очереди, но, если команда не меняет состояние образа, она пропускается. Выполняется первая и последующие команды, которые приведут образ в состояние отличное от прошлой сборки. Для этого в результате выполнения каждой команды создается новый слой (layer), для которого вычисляется значение хэш-функции. Это значение будет сравниваться с новым значением при каждой последующей сборке, и, если хэши совпадают, текущий шаг сборки будет пропущен. Поэтому имеет смысл в каждом слое объединять как можно больше команд, которые будут редко меняться. Например установку дополнительных пакетов лучше объединить в одну команду RUN. А те команды, которые будут приводить к изменению образа, лучше переносить в конец Dockerfile насколько это возможно. В нашем случае предполагается, что мы можем часто менять файл hello.py, поэтому копирование нашего скрипта в контейнер выполняется после остальных команд, непосредственно перед запуском.\nЕсли интересует, почему использую команду python -m pip install Flask вместо pip install Flask советую прочитать Зачем использовать python -m pip.\nСоберем новый образ\n$ docker build -t hello-py . Запустим контейнер с именем hello-flask из образа hello-py:latest\n$ docker run -d -p 80:5000 --name hello-flask hello-py Опция -d (или --detach) запускает контейнер в фоновом режиме. Это позволяет использовать терминал, из которого запущен контейнер, для выполнения других команд во время работы контейнера.\nОпция -p (или --port) открывает порт контейнера для взаимодействия с внешним миром. В нашем случае запросы на порт с номером 80 (дефолтный порт для http-сервера) на локальном компьютере будут перенаправлены на порт 5000 запущенного контейнера.\nТеперь мы можем открыть в браузере адрес http://localhost и увидеть наше приветствие Hello, world!\nУбедимся, что наш контейнер продолжает работать\n$ docker container ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 3371c56c3c3a hello-py \"python /hello.py\" 3 minutes ago Up 3 minutes 0.0.0.0:80-\u003e5000/tcp hello-flask В колонке STATUS видим, что контейнер запущен, а в колонке PORTS запись о перенаправлении запросов на порт с номером 5000. Прежде чем удалить работающий контейнер, его надо остановить\n$ docker container stop hello-flask Бывает, что команда stop не срабатывает, тогда можно воспользоваться командой kill\n$ docker container kill hello-flask Теперь можно контейнер удалять.\nПродолжим изменять Dockerfile\nFROM python WORKDIR /app RUN python -m pip install Flask COPY hello.py . CMD [\"python\", \"./hello.py\"] Команда WORKDIR устанавливает рабочий каталог. Если такого каталога нет, он создается. Теперь команда COPY копирует скрипт в текущий каталог, которым стал /app и скрипт выполняет по относительному пути ./hello.py.\nВместо команды ENTRYPOINT мы используем команду CMD. Разница в том, что параметры команды CMD можно подменить непосредственно из команды запуска контейнера. Например, следующая команда запустит наш контейнер, но http-сервер в нем запущен не будет, а вместо него выведется информация об установленных пакетах python\n$ docker run -it --rm --name hello-flask hello-py pip freeze click==8.0.3 Flask==2.0.2 itsdangerous==2.0.1 Jinja2==3.0.3 MarkupSafe==2.0.1 Werkzeug==2.0.2 При отладке удобно использовать команду CMD, но в конечном Dockerfile лучше использовать ENTRYPOINT, чтобы никто не смог сломать наш контейнер, передав из командной строки на выполнение незапланированную команду.\nДавайте создадим файл requirement.txt с нашими зависимостями. Пока нам нужен только Flask\nFlask==2.0.2 Изменим Dockerfile\nFROM python WORKDIR /app COPY requirement.txt . RUN python -m pip install -r requirement.txt COPY . . ENTRYPOINT [\"python\"] CMD [\"./hello.py\"] Файл requirement.txt с перечисленными зависимостями будет меняться не так часто, как скрипт, поэтому его копирование вынесли в отдельную команду. Так же я разделил запуск скрипта на две части. Позже я покажу зачем, а пока проверим, что все по-прежнему работает.\nСобираем образ\n$ docker build -t hello-py . Запускаем контейнер\n$ docker run -d --rm -p 80:5000 --name hello-flask hello-py Проверяем результат в браузере. Если все нормально контейнер можно остановить\n$ docker container stop hello-flask У нас указана опция --rm, поэтому после остановки контейнер сам удалится.\nСоздадим новый файл hello-cmd.py\nprint(\"Hello from command line\") Пересоберем образ. На этот раз образ собрался намного быстрее, чем в прошлый. Это связано с тем, что изменился только один слой, в котором мы выполняем операцию копирования всех файлов нашего каталога в текущий каталог контейнера COPY . .\nЗапустим контейнер, но в качестве дополнительного параметра укажем название нашего нового скрипта. Этот параметр заменит тот, что указан в команде CMD.\n$ docker run --rm --name hello-flask hello-py hello-cmd.py Hello from command line Проверим, что контейнер с web-сервером так же запускается.\nТаким образом, можно писать новые программы и передавать их как параметры для запуска нашему контейнеру. Только для этого придется каждый раз пересобирать образ, иначе новые программы не попадут в рабочий каталог контейнера. Это удобно, когда мы хотим распространять образ с готовой программной для запуска на других компьютерах. Но для разработки или тестирования наших программ это решение не удобно. Для этого можно смонтировать локальный каталог в качестве тома (volume) контейнера Docker. Наш локальный каталог будет доступен в файловой системе контейнера.\nУдалим команду COPY из Dockerfile\nFROM python WORKDIR /app COPY requirement.txt . RUN python -m pip install -r requirement.txt ENTRYPOINT [\"python\"] CMD [\"./hello.py\"] Пересоберем образ\n$ docker build -t hello-volume . Запустим контейнер с опцией -v. Параметром этой опции служит полный путь к каталогу, который мы ходим сделать доступным из контейнера и после : каталог в файловой системе контейнера, обращаясь к которому мы будем получать доступ к нашему локальному каталогу. В моем случае это /home/alex/projects/docker-projects/starting-docker:/app у вас путь до локального каталога, где лежат наши программы скорее всего другой.\n$ docker run -d --rm -p 80:5000 -v /home/alex/projects/docker-projects/starting-docker:/app --name hello-flask hello-volume Запустим еще один контейнер, но передадим для выполнения скрипт hello-cmd.py\n$ docker run -v /home/alex/projects/docker-projects/starting-docker:/app --name hello-cmd hello-volume hello-cmd.py Hello from command line Проверим что наши контейнеры существуют\n$ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES de7a891e4e81 hello-volume \"python hello-cmd.py\" 5 seconds ago Exited (0) 4 seconds ago hello-cmd c012bc603b88 hello-volume \"python ./hello.py\" About a minute ago Up About a minute 0.0.0.0:80-\u003e5000/tcp hello-flask Напишем еще одну программу new-hello.py\nfor i in range(10): print(\"Hello!\", end=\" === \") И запустим ее в третьем контейнере\n$ docker run -v $(pwd):/app --name new-hello hello-volume new-hello.py Hello! === Hello! === Hello! === Hello! === Hello! === Hello! === Hello! === Hello! === Hello! === Hello! === Я подключаю к контейнеру текущий каталог, поэтому вместо ввода полного пути я воспользовался командой подстановка $(pwd). Эта запись означает, что результат выполнения команды pwd - вывод полного пути к текущему каталогу, подставится в строку нашей команды на запуск контейнера.\nЕще раз убедимся, что все три контейнера существуют\n$ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c4c103819fb0 hello-volume \"python new-hello.py\" 16 seconds ago Exited (0) 15 seconds ago new-hello de7a891e4e81 hello-volume \"python hello-cmd.py\" 12 minutes ago Exited (0) 12 minutes ago hello-cmd c012bc603b88 hello-volume \"python ./hello.py\" 14 minutes ago Up 14 minutes 0.0.0.0:80-\u003e5000/tcp hello-flask Как видите, на этот раз пересобирать образ не пришлось.\nВ заключении расскажу как использовать в docker-контейнере виртуальное окружение python. Хотя Docker сам по себе изолирует среду выполнения иногда возникает необходимость воспользоваться модулем python venv. Изменим наш Dockerfile\nFROM python WORKDIR /app RUN python -m venv /venv ENV PATH=\"/venv/bin:$PATH\" COPY requirement.txt . RUN python -m pip install -r requirement.txt ENTRYPOINT [\"python\"] CMD [\"./hello.py\"] В добавленных строках мы создаем в каталоге /venv виртуальное окружение и добавляем путь к каталогу, откуда будет запускаться python в самое начало значения переменной окружения PATH.\nДля проверки того, что наша программа действительно выполнится в виртуальном окружении, напишем небольшой скрипт check-venv.py\nimport sys print(sys.prefix) print(sys.executable) Соберем образ и запустим контейнер\n$docker build -t hello-volume . $docker run --rm -v $(pwd):/app --name venv hello-volume check-venv.py /venv /venv/bin/python Всё работает.\n","wordCount":"2352","inLanguage":"en","datePublished":"2022-01-04T00:00:00Z","dateModified":"2022-01-04T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://vostbur.github.io/posts/docker-for-python-first-steps/"},"publisher":{"@type":"Organization","name":"Little things about IT","logo":{"@type":"ImageObject","url":"https://vostbur.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://vostbur.github.io/ accesskey=h title="Little things about IT (Alt + H)">Little things about IT</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://vostbur.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://vostbur.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://github.com/Vostbur title=github.com/Vostbur><span>github.com/Vostbur</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Docker для python. Первые шаги</h1><div class=post-description>Docker для python. Первые шаги.</div><div class=post-meta>&lt;span title='2022-01-04 00:00:00 +0000 UTC'>January 4, 2022&lt;/span></div></header><div class=post-content><p>Если не вдаваться в технические детали Docker ближе всего к VirtualBox, VMware или другим средствам виртуализации. Технические отличия заключаются в других способах изоляции запускаемой гостевой (guest) операционной системы и разделения ресурсов основной (host) операционной системы. Как правило каждый работающий в Docker экземпляр гостевой операционной системы предназначен для запуска одного единственного приложения. При этом задействуется меньше ресурсов, чем при запуске в виртуальной машине. Для этого создается своя файловая система, свои виртуальные сетевые интерфейсы - как бы контейнер внутри которого приложение работает. Docker это программное обеспечение для контейнеризации приложений.</p><p>Основные понятия, которые надо различать, это образ (image) и контейнер (container). Если совсем просто - образ это готовый для запуска в Docker пакет, контейнер это запущенный в Docker образ. Образ Docker можно представить как iso-образ дистрибутива операционной системы, а контейнер - запущенный экземпляр операционной системы в виртуальной машине. Из одного образа можно запустить несколько контейнеров.</p><p>Образ создается из конфигурационного текстового файла. Новый образ можно создать на основе уже существующего. Как правило конфигурационный файл начинается с команды, которая указывает на существующий образ, взятый за основу и дополняется командами для установки дополнительного программного обеспечения или изменения конфигурации.</p><p>Для опубликования своих образов существуют репозитории, самый популярный из которых Docker Hub.</p><p>Начнем с самого простого примера. Выполним команду</p><pre><code>$ docker run hello-world
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
2db29710123e: Pull complete
Digest: sha256:cc15c5b292d8525effc0f89cb299f1804f3a725c8d05e158653a563f15e4f685
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
1. The Docker client contacted the Docker daemon.
2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
    (amd64)
3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
$ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
https://hub.docker.com/

For more examples and ideas, visit:
https://docs.docker.com/get-started/
</code></pre><p>Команда <code>run</code> запускает контейнер. Разберем каждую строку</p><pre><code>Unable to find image 'hello-world:latest' locally
</code></pre><p>Сначала Docker ищет запрашиваемый образ на локальной машине, если не находит - продолжает поиск в репозитории. По умолчанию это Docker Hub. Название образа состоит из двух частей: название и версия. Docker сам добавляет номер версии <code>latest</code> к названию, если пользователь не указал что-то другое.</p><pre><code>latest: Pulling from library/hello-world
</code></pre><p>Docker нашел подходящий образ в репозитории и готов его скачать.</p><pre><code>2db29710123e: Pull complete
Digest: sha256:cc15c5b292d8525effc0f89cb299f1804f3a725c8d05e158653a563f15e4f685
Status: Downloaded newer image for hello-world:latest
</code></pre><p>Образ скачан, в выводе указан результат вычисления хэш-функции, подсчитанный по алгоритму sha256 для проверки образа.
Всё остальное это результат выполнения приложения в запущенном контейнере. Результат работы этого примера сам по себе интересен - в выводе информация об этапах запуска контейнера. Там же еще одна интересная команда</p><pre><code>$ docker run -it ubuntu bash
</code></pre><p>По этой команде запускается контейнер из образа <code>ubuntu:latest</code> и управление передается выполняемой в контейнере командной оболочке bash.</p><p>Опции <code>-i</code> или <code>--interactive</code> и <code>-t</code> или <code>--tty</code> (или вместе <code>-it</code>) позволяют запустить в контейнере интерактивные (взаимодействующие с пользователем) приложение. Они указывают Docker оставить стандартный вход (stdin) в открытом состоянии и выделить псевдо-терминал, который соединяет используемый терминал с потоками stdin и stdout контейнера. Если это сложно, то достаточно запомнить, что опции <code>-it</code> позволяют перейти в контейнер и запустить команду, ожидающую ввода пользователя.</p><p>Например команда</p><pre><code>$ docker run -it --rm python
</code></pre><p>Запустит REPL python последней версии. Опция <code>--rm</code> автоматически удаляет контейнер после того, как его выполнение завершится.</p><p>Теперь создадим свой первый образ для запуска контейнера, который будет выполнять скрипт на python. Скрипт самый простой</p><pre><code>print(&quot;Hello, world!&quot;)
</code></pre><p>сохраним его в файл <code>hello.py</code>. Конфигурационный файл docker-образа называется <code>Dockerfile</code>. Создадим Dockerfile такого содержания:</p><pre><code>FROM python
COPY hello.py /
ENTRYPOINT [ &quot;python&quot;, &quot;./example.py&quot; ]
</code></pre><p>Каждая строчка файла начинается с команды. Команды принято записывать заглавными буквами, но это не обязательно. Команды выполняются последовательно, в том порядке, в каком они указаны в Dockerfile.</p><p><code>FROM python</code> - указываем, что будем делать свой образ на основе базового образа python последней версии (latest) из репозитория Docker Hub.</p><p><code>COPY hello.py /</code> - скопируем наш скрипт <code>hello.py</code> из текущего каталога (тот же каталог, где находится и Dockerfile) в корневой каталог файловой системы образа.</p><p><code>ENTRYPOINT [ "python", "/hello.py" ]</code> - запустим наш скрипт командой python <code>/hello.py</code></p><p>Теперь соберем наш образ командой <code>build</code></p><pre><code>$ docker build -t hello-py:1.0 .
</code></pre><p>Точка в конце команды указывает, что Dockerfile для сборки образа находится в текущем каталоге.</p><p>Опция <code>-t</code> (tag) команды <code>build</code> позволяет задать имя и версию нашему образу. Если версию не указывать, Docker автоматически добавить latest. Если не указывать имя, к образу можно будет обратиться по значению <code>IMAGE ID</code>. Узнать, какие образы у нас уже есть можно командой</p><pre><code>$ docker images
</code></pre><p>или</p><pre><code>$ docker image ls
</code></pre><p>Это идентичные команды, но лучше пользоваться вторым вариантом. Он введен для приведения команд Docker к некоторому унифицированному виду. Все команды, которые управляют образами находятся в разделе <code>docker image</code>, контейнерами - <code>docker container</code>.</p><pre><code>REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
&lt;none&gt;       &lt;none&gt;    6af91789bf03   20 minutes ago   917MB
python       latest    a42e2a4f3833   5 days ago       917MB
</code></pre><p>Здесь видно, что при создании образа не было указано имя. Контейнер в таком случае можно запустить командой</p><pre><code>$ docker run 6af91789bf03
</code></pre><p>Если указано имя, команда для запуска контейнера может быть более удобочитаемой</p><pre><code>$ docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
hello-py     1.0       6af91789bf03   22 minutes ago   917MB
python       latest    a42e2a4f3833   5 days ago       917MB

$ docker run hello-py:1.0
</code></pre><p>Контейнер мы запустили без опции <code>--rm</code>, значит после завершения выполнения, он не удалился. Посмотреть существующие контейнеры можно командой</p><pre><code>$ docker ps -a
</code></pre><p>или</p><pre><code>$ docker container ls -a
</code></pre><p>Команды идентичны, как в случает с <code>docker images</code> и <code>docker image ls</code>. Опция <code>-a</code> указывает выводить все контейнеры, запущенные и уже остановленные</p><pre><code>$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND              CREATED         STATUS                     PORTS     NAMES
9839a6c57209   hello-py:1.0   &quot;python /hello.py&quot;   5 seconds ago   Exited (0) 4 seconds ago             upbeat_noyce
</code></pre><p>Каждому контейнеру присваивается случайное имя. В этом случае это <code>upbeat_noyce</code>. Но при создании контейнера можно указать и свое значение имени используя опцию <code>--name</code>.</p><pre><code>$ docker run --name hello-world hello-py:1.0
</code></pre><p>в этом случае список контейнеров будет такой</p><pre><code>$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND              CREATED          STATUS                      PORTS     NAMES
11794828bf57   hello-py:1.0   &quot;python /hello.py&quot;   29 seconds ago   Exited (0) 29 seconds ago             hello-world
9839a6c57209   hello-py:1.0   &quot;python /hello.py&quot;   3 minutes ago    Exited (0) 3 minutes ago              upbeat_noyce
</code></pre><p>Удалить остановленные контейнеры можно командой <code>docker container rm &lt;имя_контейнера></code></p><pre><code>$ docker container rm hello-world
</code></pre><p>Удалить локальные образы можно командой <code>docker image rm &lt;имя образа></code></p><pre><code>$ docker image rm hello-py:1.0
</code></pre><p>Усложним наш скрипт. Запустим в контейнере web-приложение выводящее на главную страницу <code>Hello, world!</code> В качестве сервера будем использовать Flask.</p><p>Наш новый файл <code>hello.py</code></p><pre><code>from flask import Flask

app = Flask(__name__)


@app.route(&quot;/&quot;)
def index():
    return &quot;Hello, world!&quot;


if __name__ == &quot;__main__&quot;:
    app.run(host=&quot;0.0.0.0&quot;, port=5000)
</code></pre><p>Изменим Dockerfile, добавим только одну команду, с помощью которой установим flask.</p><pre><code>FROM python
RUN python -m pip install Flask
COPY hello.py /
ENTRYPOINT [&quot;python&quot;, &quot;/hello.py&quot;]
</code></pre><p>Немного о порядке команд в Dockerfile. Docker выполняет команды по очереди, но, если команда не меняет состояние образа, она пропускается. Выполняется первая и последующие команды, которые приведут образ в состояние отличное от прошлой сборки. Для этого в результате выполнения каждой команды создается новый слой (layer), для которого вычисляется значение хэш-функции. Это значение будет сравниваться с новым значением при каждой последующей сборке, и, если хэши совпадают, текущий шаг сборки будет пропущен. Поэтому имеет смысл в каждом слое объединять как можно больше команд, которые будут редко меняться. Например установку дополнительных пакетов лучше объединить в одну команду <code>RUN</code>. А те команды, которые будут приводить к изменению образа, лучше переносить в конец Dockerfile насколько это возможно. В нашем случае предполагается, что мы можем часто менять файл <code>hello.py</code>, поэтому копирование нашего скрипта в контейнер выполняется после остальных команд, непосредственно перед запуском.</p><p>Если интересует, почему использую команду <code>python -m pip install Flask</code> вместо <code>pip install Flask</code> советую прочитать <a href=https://habr.com/ru/company/otus/blog/475392/>Зачем использовать python -m pip</a>.</p><p>Соберем новый образ</p><pre><code>$ docker build -t hello-py .
</code></pre><p>Запустим контейнер с именем <code>hello-flask</code> из образа <code>hello-py:latest</code></p><pre><code>$ docker run -d -p 80:5000 --name hello-flask hello-py
</code></pre><p>Опция <code>-d</code> (или <code>--detach</code>) запускает контейнер в фоновом режиме. Это позволяет использовать терминал, из которого запущен контейнер, для выполнения других команд во время работы контейнера.</p><p>Опция <code>-p</code> (или <code>--port</code>) открывает порт контейнера для взаимодействия с внешним миром. В нашем случае запросы на порт с номером 80 (дефолтный порт для http-сервера) на локальном компьютере будут перенаправлены на порт 5000 запущенного контейнера.</p><p>Теперь мы можем открыть в браузере адрес http://localhost и увидеть наше приветствие <code>Hello, world!</code></p><p>Убедимся, что наш контейнер продолжает работать</p><pre><code>$ docker container ps
CONTAINER ID   IMAGE      COMMAND              CREATED         STATUS         PORTS                  NAMES
3371c56c3c3a   hello-py   &quot;python /hello.py&quot;   3 minutes ago   Up 3 minutes   0.0.0.0:80-&gt;5000/tcp   hello-flask
</code></pre><p>В колонке <code>STATUS</code> видим, что контейнер запущен, а в колонке <code>PORTS</code> запись о перенаправлении запросов на порт с номером 5000.
Прежде чем удалить работающий контейнер, его надо остановить</p><pre><code>$ docker container stop hello-flask
</code></pre><p>Бывает, что команда <code>stop</code> не срабатывает, тогда можно воспользоваться командой <code>kill</code></p><pre><code>$ docker container kill hello-flask
</code></pre><p>Теперь можно контейнер удалять.</p><p>Продолжим изменять Dockerfile</p><pre><code>FROM python
WORKDIR /app
RUN python -m pip install Flask
COPY hello.py .
CMD [&quot;python&quot;, &quot;./hello.py&quot;]
</code></pre><p>Команда <code>WORKDIR</code> устанавливает рабочий каталог. Если такого каталога нет, он создается. Теперь команда <code>COPY</code> копирует скрипт в текущий каталог, которым стал <code>/app</code> и скрипт выполняет по относительному пути <code>./hello.py</code>.</p><p>Вместо команды <code>ENTRYPOINT</code> мы используем команду <code>CMD</code>. Разница в том, что параметры команды <code>CMD</code> можно подменить непосредственно из команды запуска контейнера. Например, следующая команда запустит наш контейнер, но http-сервер в нем запущен не будет, а вместо него выведется информация об установленных пакетах python</p><pre><code>$ docker run -it --rm --name hello-flask hello-py pip freeze
click==8.0.3
Flask==2.0.2
itsdangerous==2.0.1
Jinja2==3.0.3
MarkupSafe==2.0.1
Werkzeug==2.0.2
</code></pre><p>При отладке удобно использовать команду <code>CMD</code>, но в конечном Dockerfile лучше использовать <code>ENTRYPOINT</code>, чтобы никто не смог сломать наш контейнер, передав из командной строки на выполнение незапланированную команду.</p><p>Давайте создадим файл <code>requirement.txt</code> с нашими зависимостями. Пока нам нужен только Flask</p><pre><code>Flask==2.0.2
</code></pre><p>Изменим Dockerfile</p><pre><code>FROM python
WORKDIR /app
COPY requirement.txt .
RUN python -m pip install -r requirement.txt
COPY . .
ENTRYPOINT [&quot;python&quot;]
CMD [&quot;./hello.py&quot;]
</code></pre><p>Файл <code>requirement.txt</code> с перечисленными зависимостями будет меняться не так часто, как скрипт, поэтому его копирование вынесли в отдельную команду. Так же я разделил запуск скрипта на две части. Позже я покажу зачем, а пока проверим, что все по-прежнему работает.</p><p>Собираем образ</p><pre><code>$ docker build -t hello-py .
</code></pre><p>Запускаем контейнер</p><pre><code>$ docker run -d --rm -p 80:5000 --name hello-flask hello-py
</code></pre><p>Проверяем результат в браузере. Если все нормально контейнер можно остановить</p><pre><code>$ docker container stop hello-flask
</code></pre><p>У нас указана опция <code>--rm</code>, поэтому после остановки контейнер сам удалится.</p><p>Создадим новый файл <code>hello-cmd.py</code></p><pre><code>print(&quot;Hello from command line&quot;)
</code></pre><p>Пересоберем образ. На этот раз образ собрался намного быстрее, чем в прошлый. Это связано с тем, что изменился только один слой, в котором мы выполняем операцию копирования всех файлов нашего каталога в текущий каталог контейнера <code>COPY . .</code></p><p>Запустим контейнер, но в качестве дополнительного параметра укажем название нашего нового скрипта. Этот параметр заменит тот, что указан в команде <code>CMD</code>.</p><pre><code>$ docker run --rm --name hello-flask hello-py hello-cmd.py
Hello from command line
</code></pre><p>Проверим, что контейнер с web-сервером так же запускается.</p><p>Таким образом, можно писать новые программы и передавать их как параметры для запуска нашему контейнеру. Только для этого придется каждый раз пересобирать образ, иначе новые программы не попадут в рабочий каталог контейнера. Это удобно, когда мы хотим распространять образ с готовой программной для запуска на других компьютерах. Но для разработки или тестирования наших программ это решение не удобно. Для этого можно смонтировать локальный каталог в качестве тома (volume) контейнера Docker. Наш локальный каталог будет доступен в файловой системе контейнера.</p><p>Удалим команду <code>COPY</code> из Dockerfile</p><pre><code>FROM python
WORKDIR /app
COPY requirement.txt .
RUN python -m pip install -r requirement.txt
ENTRYPOINT [&quot;python&quot;]
CMD [&quot;./hello.py&quot;]
</code></pre><p>Пересоберем образ</p><pre><code>$ docker build -t hello-volume .
</code></pre><p>Запустим контейнер с опцией <code>-v</code>. Параметром этой опции служит полный путь к каталогу, который мы ходим сделать доступным из контейнера и после <code>:</code> каталог в файловой системе контейнера, обращаясь к которому мы будем получать доступ к нашему локальному каталогу. В моем случае это <code>/home/alex/projects/docker-projects/starting-docker:/app</code> у вас путь до локального каталога, где лежат наши программы скорее всего другой.</p><pre><code>$ docker run -d --rm -p 80:5000 -v /home/alex/projects/docker-projects/starting-docker:/app --name hello-flask hello-volume
</code></pre><p>Запустим еще один контейнер, но передадим для выполнения скрипт <code>hello-cmd.py</code></p><pre><code>$ docker run -v /home/alex/projects/docker-projects/starting-docker:/app --name hello-cmd hello-volume hello-cmd.py
Hello from command line
</code></pre><p>Проверим что наши контейнеры существуют</p><pre><code>$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                 CREATED              STATUS                     PORTS                  NAMES
de7a891e4e81   hello-volume   &quot;python hello-cmd.py&quot;   5 seconds ago        Exited (0) 4 seconds ago                          hello-cmd
c012bc603b88   hello-volume   &quot;python ./hello.py&quot;     About a minute ago   Up About a minute          0.0.0.0:80-&gt;5000/tcp   hello-flask
</code></pre><p>Напишем еще одну программу <code>new-hello.py</code></p><pre><code>for i in range(10):
    print(&quot;Hello!&quot;, end=&quot; === &quot;)
</code></pre><p>И запустим ее в третьем контейнере</p><pre><code>$ docker run -v $(pwd):/app --name new-hello hello-volume
new-hello.py
Hello! === Hello! === Hello! === Hello! === Hello! === Hello! === Hello! === Hello! === Hello! === Hello! ===
</code></pre><p>Я подключаю к контейнеру текущий каталог, поэтому вместо ввода полного пути я воспользовался командой подстановка <code>$(pwd)</code>. Эта запись означает, что результат выполнения команды <code>pwd</code> - вывод полного пути к текущему каталогу, подставится в строку нашей команды на запуск контейнера.</p><p>Еще раз убедимся, что все три контейнера существуют</p><pre><code>$ docker container ls -a
CONTAINER ID   IMAGE          COMMAND                 CREATED          STATUS                      PORTS                  NAMES
c4c103819fb0   hello-volume   &quot;python new-hello.py&quot;   16 seconds ago   Exited (0) 15 seconds ago                          new-hello
de7a891e4e81   hello-volume   &quot;python hello-cmd.py&quot;   12 minutes ago   Exited (0) 12 minutes ago                          hello-cmd
c012bc603b88   hello-volume   &quot;python ./hello.py&quot;     14 minutes ago   Up 14 minutes               0.0.0.0:80-&gt;5000/tcp   hello-flask
</code></pre><p>Как видите, на этот раз пересобирать образ не пришлось.</p><p>В заключении расскажу как использовать в docker-контейнере виртуальное окружение python. Хотя Docker сам по себе изолирует среду выполнения иногда возникает необходимость воспользоваться модулем <code>python venv</code>. Изменим наш Dockerfile</p><pre><code>FROM python
WORKDIR /app
RUN python -m venv /venv
ENV PATH=&quot;/venv/bin:$PATH&quot;
COPY requirement.txt .
RUN python -m pip install -r requirement.txt
ENTRYPOINT [&quot;python&quot;]
CMD [&quot;./hello.py&quot;]
</code></pre><p>В добавленных строках мы создаем в каталоге <code>/venv</code> виртуальное окружение и добавляем путь к каталогу, откуда будет запускаться python в самое начало значения переменной окружения <code>PATH</code>.</p><p>Для проверки того, что наша программа действительно выполнится в виртуальном окружении, напишем небольшой скрипт <code>check-venv.py</code></p><pre><code>import sys
print(sys.prefix)
print(sys.executable)
</code></pre><p>Соберем образ и запустим контейнер</p><pre><code>$docker build -t hello-volume .
$docker run --rm -v $(pwd):/app --name venv hello-volume check-venv.py
/venv
/venv/bin/python
</code></pre><p>Всё работает.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://vostbur.github.io/tags/python/>Python</a></li><li><a href=https://vostbur.github.io/tags/docker/>Docker</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Docker для python. Первые шаги on twitter" href="https://twitter.com/intent/tweet/?text=Docker%20%d0%b4%d0%bb%d1%8f%20python.%20%d0%9f%d0%b5%d1%80%d0%b2%d1%8b%d0%b5%20%d1%88%d0%b0%d0%b3%d0%b8&amp;url=https%3a%2f%2fvostbur.github.io%2fposts%2fdocker-for-python-first-steps%2f&amp;hashtags=python%2cdocker"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Docker для python. Первые шаги on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvostbur.github.io%2fposts%2fdocker-for-python-first-steps%2f&amp;title=Docker%20%d0%b4%d0%bb%d1%8f%20python.%20%d0%9f%d0%b5%d1%80%d0%b2%d1%8b%d0%b5%20%d1%88%d0%b0%d0%b3%d0%b8&amp;summary=Docker%20%d0%b4%d0%bb%d1%8f%20python.%20%d0%9f%d0%b5%d1%80%d0%b2%d1%8b%d0%b5%20%d1%88%d0%b0%d0%b3%d0%b8&amp;source=https%3a%2f%2fvostbur.github.io%2fposts%2fdocker-for-python-first-steps%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Docker для python. Первые шаги on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fvostbur.github.io%2fposts%2fdocker-for-python-first-steps%2f&title=Docker%20%d0%b4%d0%bb%d1%8f%20python.%20%d0%9f%d0%b5%d1%80%d0%b2%d1%8b%d0%b5%20%d1%88%d0%b0%d0%b3%d0%b8"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Docker для python. Первые шаги on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvostbur.github.io%2fposts%2fdocker-for-python-first-steps%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Docker для python. Первые шаги on whatsapp" href="https://api.whatsapp.com/send?text=Docker%20%d0%b4%d0%bb%d1%8f%20python.%20%d0%9f%d0%b5%d1%80%d0%b2%d1%8b%d0%b5%20%d1%88%d0%b0%d0%b3%d0%b8%20-%20https%3a%2f%2fvostbur.github.io%2fposts%2fdocker-for-python-first-steps%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Docker для python. Первые шаги on telegram" href="https://telegram.me/share/url?text=Docker%20%d0%b4%d0%bb%d1%8f%20python.%20%d0%9f%d0%b5%d1%80%d0%b2%d1%8b%d0%b5%20%d1%88%d0%b0%d0%b3%d0%b8&amp;url=https%3a%2f%2fvostbur.github.io%2fposts%2fdocker-for-python-first-steps%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://vostbur.github.io/>Little things about IT</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>